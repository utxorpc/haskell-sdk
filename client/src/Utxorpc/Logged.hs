{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RankNTypes #-}

module Utxorpc.Logged
  ( UtxorpcClientLogger (..),
    RequestLogger,
    ReplyLogger,
    ServerStreamDataLogger,
    ServerStreamEndLogger,
    loggedSStream,
    loggedUnary,
  )
where

import Control.Monad.IO.Class (liftIO)
import qualified Data.ByteString.Char8 as BS
import Data.ProtoLens (Message)
import Network.GRPC.Client (HeaderList, RawReply)
import Network.GRPC.Client.Helpers (GrpcClient (..), rawStreamServer, rawUnary)
import Network.GRPC.HTTP2.Encoding (GRPCInput, GRPCOutput)
import Network.GRPC.HTTP2.Types (IsRPC (..))
import Network.HTTP2.Client (runClientIO)
import Utxorpc.Types (ServerStreamReply, UnaryReply)

{--------------------------------------
  Types
--------------------------------------}

-- In the following logger types:
--
-- The ByteString is the method path
--
-- The GrcpClient is included because it contains useful information such as the server
-- address
--
-- Values of type `a` are generated by the request logger and passed down the line
-- to the other logging functions during a gRPC call.
-- For example, the request logger performs a logging action and returns a (UUID, Int)
-- describing the call ID and the number of replies received. For a server stream RPC,
-- the (UUID, Int) is then passed to the server chunk logger, which increments the Int
-- for data chunk received. The final (UUID, Int) is then passed to the ServerStreamEndLogger.

-- Note that `a` has no connection the functions that actually process the RPC replies.
data UtxorpcClientLogger m a = UtxorpcClientLogger
  { requestL :: RequestLogger m a,
    replyL :: ReplyLogger m a,
    serverStreamDataL :: ServerStreamDataLogger m a,
    serverStreamEndL :: ServerStreamEndLogger m a,
    unlift :: forall x. m x -> IO x
  }

type RequestLogger m a =
  forall i.
  (Show i, Message i) =>
  BS.ByteString ->
  GrpcClient ->
  i -> -- Message sent to the service
  m a -- This value is fed to downstream loggers

type ReplyLogger m a =
  forall o.
  (Show o, Message o) =>
  BS.ByteString ->
  GrpcClient ->
  a -> -- Value generated by the RequestLogger for this RPC call.
  RawReply o -> -- Message received from the service (with headers)
  m ()

type ServerStreamDataLogger m a =
  forall o.
  (Show o, Message o) =>
  BS.ByteString ->
  GrpcClient ->
  a -> -- Value generated by the RequestLogger for this RPC call.
  o -> -- Message received from the service
  m a -- Value passed to subsequent invocations of this function and the ServerStreamEndLogger

-- Note that the `a` here is the value generated by the logger, not by the function that processes
-- the server stream messages.
type ServerStreamEndLogger m a =
  BS.ByteString ->
  GrpcClient ->
  (a, HeaderList, HeaderList) -> -- The final value generated by the ServerStreamDataLogger
  m ()

{--------------------------------------
  Logged wrappers of gRPC library functions
--------------------------------------}

loggedUnary ::
  (GRPCInput r i, GRPCOutput r o, Show i, Message i, Show o, Message o) =>
  Maybe (UtxorpcClientLogger m a) ->
  r ->
  GrpcClient ->
  i ->
  UnaryReply o
loggedUnary logger r client i =
  runClientIO $
    maybe (rawUnary r client i) logged logger
  where
    logged UtxorpcClientLogger {requestL, replyL, unlift} = do
      a <- liftIO . unlift $ requestL (path r) client i
      o <- rawUnary r client i
      case o of
        Right rawReply -> liftIO . unlift $ replyL (path r) client a rawReply
        _ -> return () {-- TODO: Need to handle `TooMuchConcurrency` --}
      return o

loggedSStream ::
  (GRPCOutput r o, GRPCInput r i, Show i, Message i, Show o, Message o) =>
  Maybe (UtxorpcClientLogger m b) ->
  r ->
  GrpcClient ->
  a ->
  i ->
  (a -> HeaderList -> o -> IO a) ->
  ServerStreamReply a
loggedSStream logger r client initStreamState req chunkHandler =
  runClientIO $
    maybe
      (rawStreamServer r client initStreamState req liftedChunkHandler)
      logged
      logger
  where
    liftedChunkHandler streamState headerList reply = liftIO $ chunkHandler streamState headerList reply

    logged
      UtxorpcClientLogger {requestL, serverStreamDataL, serverStreamEndL, unlift} = do
        initLogState <- liftIO logRequestIO
        streamResult <- runLoggedStream initLogState
        handleStreamResult streamResult
        where
          -- The gRPC library requires a handler that produces a `ClientIO`,
          -- but this does not make sense since a user-provided handler is not
          -- likely to generate a `ClientError` or `TooMuchConcurrency`.
          -- Instead, we accept a handler of type `IO` and lift it.
          logRequestIO = unlift $ requestL rpcPath client req

          runLoggedStream initLogState =
            rawStreamServer r client (initStreamState, initLogState) req loggedChunkHandler

          loggedChunkHandler state hl o = do
            a <- liftedChunkHandler (fst state) hl o
            b <- liftIO . unlift $ serverStreamDataL rpcPath client (snd state) o
            return (a, b)

          handleStreamResult streamResult =
            case streamResult of
              Right ((finalStreamState, finalLogState), hl, hl') -> do
                liftIO $ logEndOfStreamIO finalLogState hl hl'
                return $ Right (finalStreamState, hl, hl')
              Left tmc -> return $ Left tmc

          logEndOfStreamIO finalLogState hl hl' =
            unlift $ serverStreamEndL rpcPath client (finalLogState, hl, hl')

          rpcPath = path r
