{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RankNTypes #-}

module Utxorpc.Logged
  ( UtxorpcClientLogger,
    RequestLogger,
    ReplyLogger,
    ServerChunkLogger,
    ServerStreamEndLogger,
    loggedSStream,
    loggedUnary,
  )
where

import Control.Monad.IO.Class (liftIO)
import qualified Data.ByteString.Char8 as BS
import Data.ProtoLens (Message)
import Network.GRPC.Client (HeaderList, RawReply)
import Network.GRPC.Client.Helpers (GrpcClient (..), GrpcClientConfig, UseTlsOrNot, close, rawStreamServer, rawUnary)
import Network.GRPC.HTTP2.Encoding (GRPCInput, GRPCOutput)
import Network.GRPC.HTTP2.Types (IsRPC (..))
import Network.HTTP2.Client (ClientIO, HostName, PortNumber)
import Network.HTTP2.Client.Exceptions (ClientIO)
import Utxorpc.Types (ServerStreamReply, UnaryReply, UtxorpcService)

{--------------------------------------
  Types
--------------------------------------}

-- In the following logger types:
--
-- The ByteString is the method path
--
-- The GrcpClient is included because it contains useful information such as the server
-- address
--
-- Values of type `a` are generated by the request logger and passed down the line
-- to the other logging functions during a gRPC call.
-- For example, the request logger performs a logging action and returns a (UUID, Int)
-- describing the call ID and the number of replies received. For a server stream RPC,
-- the (UUID, Int) is then passed to the server chunk logger, which increments the Int
-- for data chunk received. The final (UUID, Int) is then passed to the ServerStreamEndLogger.

data UtxorpcClientLogger m a = UtxorpcClientLogger
  { requestL :: RequestLogger m a,
    replyL :: ReplyLogger m a,
    serverStreamDataL :: ServerChunkLogger m a,
    serverStreamEndL :: ServerStreamEndLogger m a,
    unlift :: forall x. m x -> IO x
  }

type RequestLogger m a =
  forall i.
  (Show i, Message i) =>
  BS.ByteString ->
  GrpcClient ->
  i -> -- Message sent to the service
  m a -- This value is fed to downstream loggers

type ReplyLogger m a =
  forall o.
  (Show o, Message o) =>
  BS.ByteString ->
  GrpcClient ->
  a -> -- Value generated by the RequestLogger for this RPC call.
  RawReply o -> -- Message received from the service (with headers)
  m ()

type ServerChunkLogger m a =
  forall o.
  (Show o, Message o) =>
  BS.ByteString ->
  GrpcClient ->
  a -> -- Value generated by the RequestLogger for this RPC call.
  o -> -- Message received from the service
  m a -- Value passed to subsequent invocations of this function and the ServerStreamEndLogger

-- Note that the `a` here is the value generated by the logger, not by the function that processes
-- the server stream messages.
type ServerStreamEndLogger m a =
  BS.ByteString ->
  GrpcClient ->
  (a, HeaderList, HeaderList) -> -- The final value generated by the ServerChunkLogger
  m ()

{--------------------------------------
  Logged wrappers of gRPC library functions
--------------------------------------}

loggedUnary ::
  (GRPCInput r i, GRPCOutput r o, Show i, Message i, Show o, Message o) =>
  Maybe (UtxorpcClientLogger m a) ->
  r ->
  GrpcClient ->
  i ->
  UnaryReply o
loggedUnary = maybe rawUnary loggedUnary'

loggedUnary' ::
  (GRPCInput r i, GRPCOutput r o, Show i, Message i, Show o, Message o) =>
  UtxorpcClientLogger m a ->
  r ->
  GrpcClient ->
  i ->
  UnaryReply o
loggedUnary' (UtxorpcClientLogger {requestL, replyL, unlift}) r client i = do
  a <- liftIO . unlift $ requestL (path r) client i
  o <- rawUnary r client i
  case o of
    Right rawReply -> liftIO . unlift $ replyL (path r) client a rawReply
    _ -> return () {-- TODO: Need to handle `TooMuchConcurrency` --}
  return o

loggedSStream ::
  (GRPCOutput r o, GRPCInput r i, Show i, Message i, Show o, Message o) =>
  Maybe (UtxorpcClientLogger m c) ->
  r ->
  GrpcClient ->
  a ->
  i ->
  (a -> HeaderList -> o -> ClientIO a) ->
  ServerStreamReply a
loggedSStream = maybe rawStreamServer loggedSStream'

loggedSStream' ::
  (GRPCOutput r o, GRPCInput r i, Show i, Message i, Show o, Message o) =>
  UtxorpcClientLogger m c ->
  r ->
  GrpcClient ->
  a ->
  i ->
  (a -> HeaderList -> o -> ClientIO a) ->
  ServerStreamReply a
loggedSStream'
  (UtxorpcClientLogger {requestL, serverStreamDataL, serverStreamEndL, unlift})
  r
  client
  initStreamState
  req
  chunkHandler = do
    initLogState <- liftIO logRequestIO
    streamResult <- runLoggedStream initLogState
    handleStreamResult streamResult
    where
      logRequestIO = unlift $ requestL rpcPath client req

      runLoggedStream initLogState =
        rawStreamServer r client (initStreamState, initLogState) req loggedChunkHandler

      loggedChunkHandler state hl o = do
        a <- chunkHandler (fst state) hl o
        b <- liftIO . unlift $ serverStreamDataL rpcPath client (snd state) o
        return (a, b)

      handleStreamResult streamResult =
        case streamResult of
          Right ((finalStreamState, finalLogState), hl, hl') -> do
            liftIO $ logEndOfStreamIO finalLogState hl hl'
            return $ Right (finalStreamState, hl, hl')
          Left tmc -> return $ Left tmc

      logEndOfStreamIO finalLogState hl hl' =
        unlift $ serverStreamEndL rpcPath client (finalLogState, hl, hl')

      rpcPath = path r
